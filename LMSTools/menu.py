import json

from .menuitems import (NextMenuItem,
                       PlaylistMenuItem,
                       SearchMenuItem,
                       AudioMenuItem)


class LMSMenuException(Exception):
    """Simple exception class for handling errors in the LMSMenuHandler."""
    pass


class LMSMenuHandler(object):
    """
    :type player: LMSPlayer
    :param player: instance of LMSPlayer.

    Class for generating squeezeplayer menu for individual players.

    This code is a work in progress and currently has limited functionality.

    Menus can be requested via the getHomeMenu or getCustomMenu methods. \
    Subsequent menus are generated by getting the menu command from previous \
    menus and passing it to the getMenu method.

    If no player is set when the handler is initiated then it must be set \
    before requesting menus.
    """

    def __init__(self, player=None):
        self.player = player
        self.rootmenu = ["menu", "items", 0, 1000, "direct:1"]

    def _request(self, menucmd):
        if self.player is None:
            raise LMSMenuException("player must be set before requesting menu.")
        self.result = self.player.request(menucmd)
        return self.result

    def changePlayer(self, player):
        """
        :type player: LMSPlayer
        :param player: instance of LMSPlayer.

        Change the player for which the menu is being created.

        While this may have little relevance on retrieiving menus, it is \
        important if you wish to manipulate the playlist or other player \
        specific items directly from the menu.
        """
        self.player = player

    def getCustomMenu(self, raw):
        """
        :type raw: dict
        :param raw: custom menu format (see docs for example)
        :rtype: list
        :returns: list of menu items

        Generate menu items from a custom menu.

        This can be useful if you want to create a tailored menu rather than \
        use the full default menu generated by the server.
        """

        processed = self._process_menu(raw)
        return processed

    def getHomeMenu(self):
        """
        :rtype: list
        :returns: list of menu items

        Generate menu items from default menu.
        """
        raw = self._request(self.rootmenu)
        processed = self._process_menu(raw)
        return processed

    def dump(self, menu, filename):
        """
        :type menu: dict
        :param menu: raw json menu
        :type filename: str
        :param filename: name of file to save menu

        Save the supplied menu to file (useful for debugging purposes).
        """
        with open(filename, "w") as dumpfile:
            json.dump(menu, dumpfile, indent=4)

    def getMenu(self, menucmd):
        """
        :type menucmd: str, list
        :param menucmd: command to request next menu from server
        :rtype: list
        :returns: list of menu items

        Generate menu from the supplied menu command.
        """
        raw = self._request(menucmd)
        processed = self._process_menu(raw)

        return processed

    def _process_menu(self, raw_menu):

        processed = []

        for item in raw_menu.get("item_loop"):

            menutype = item.get("type")
            style = item.get("style")

            kwargs = {"player": self.player,
                      "menuitem": item,
                      "base": raw_menu.get("base", None)}

            if menutype == "audio" or (menutype == "link" and style == "itemplay"):
                entry = AudioMenuItem(**kwargs)

            elif menutype == "playlist" or self._is_playable(item, raw_menu.get("base")):
                entry = PlaylistMenuItem(**kwargs)

            elif menutype == "search":
                entry = SearchMenuItem(**kwargs)

            else:
                entry = NextMenuItem(**kwargs)

            processed.append(entry)

        return processed

    def _is_playable(self, item, base=None):
        playable = ["play", "playControl"]
        if base is None:
            return False

        item_act = item.get("goAction", False)
        if item_act in playable:
            return True
        else:
            return False
